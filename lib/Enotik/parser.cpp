
/**************************************************************************************
Файл, содержащий описание всех методов класса Parser. Класс Parser отвечает за 
обработку и проверку полученного пакета.
Разработчик: Семухин Богдан
**************************************************************************************/
#include "parser.h"
#include "crc8.h"
#include "Enotik_master.h"
extern EnotikMaster Enotik;

/**************************************************************************************
Метод parse класса Parser необходим для обработки и проверки полученного байта, 
формирования пакета значащих байта. В этом методе идет проверка crc8, стартового байта.
Если пришел пакет мусора, в котором есть часть нужного нам пакета, то данный метод выки-
дывает ненужные байты и формирует адекватный пакет, осуществляя сдвиг ранее набранного
массива.

Принимаемые аргументы:

byte data - пришедший байт на USART
**************************************************************************************/
void Parser:: parse(byte data)
{
  //Если сейчас находимся в начале массива 
  if(count_data==ENOTIK_ID_OFFSET)
  {
    //и при этом если полученный байт совпадает с заданным id
    if(data==id)
    {
      //Записываем в начало массива заданный id, начиная формировать пакет.
      message[ENOTIK_ID_OFFSET]=id;
      //перешли к следующему элементу массива
      count_data++;
    }
  }
  //Если же мы находимся НЕ в начале массива, но и не в конце
  else if(count_data>ENOTIK_ID_OFFSET && count_data<ENOTIK_MESSAGE_LENGTH-1)
  {
    //заполняем пакет до конца.
    message[count_data]=data;
    count_data++;
  }
  else 
  { 
    //если мы набрали пакет.  
    message[count_data]=data;
    //проверяем, сошлась ли crc8 посчитанная и полученная последним байтом 
    if(crc8(message,ENOTIK_MESSAGE_LENGTH-1)==message[ENOTIK_CRC8_OFFSET])
    {
      //если сошлась, заполняем масссив значащих байт 
      Enotik.on_message_received (message[ENOTIK_OPPCODE_OFFSET],message[ENOTIK_DATALOW_OFFSET],message[ENOTIK_DATAHIGH_OFFSET]);
      //идем в начало массива.
      count_data=0;
    }
    //если не сошлась
    else
    {
      //в набранном пакете ищем байт, совпадающий с заданным id
      for(byte i=1;i<ENOTIK_MESSAGE_LENGTH;i++)             //если чек сумма не сошлась, ищем в пакете адресный байт и набираем пакет заново
      {
        //если мы его нашли
        if(message[i]==id)
        {
          //вызываем функцию сдвига всего массива до момента, пока байт id не станет нулевым
          count_data=ENOTIK_MESSAGE_LENGTH-i;
          shiftLeft(i);
          return;
        }
      }
      count_data=0;
    }
  }
}


/**************************************************************************************
Метод shiftLeft класса Parser необходим для сдвига всех элементов массива на определенное число позиций.

Принимаемые аргументы:

byte amount - количество позиций, на которое надо сдвинуть массив
**************************************************************************************/

void Parser::shiftLeft(byte amount)
{
  for(byte i=0, j=amount; i<ENOTIK_MESSAGE_LENGTH-amount; i++, j++)
  {
    message[i] = message[j];  
  }    
}
/**************************************************************************************
Метод init_slave класса Parser необходим для инициализации устройства как slave
и присвоения устройству своего id. Slave id отличается от id мастера 0 в старшем бите 
байта id.
Метод init_master работает по тому же принципу, отличия в старшем бите байта id.

Принимаемые аргументы:

byte id_master(id_slave) - назначаемый пользователем id устройства.

**************************************************************************************/
void Parser::init_master(byte id_master)
{
  id=id_master | 1<<7;
  count_data=0;  
}

void Parser::init_slave(byte id_slave)
{
  id=id_slave;
  count_data=0;  
}

